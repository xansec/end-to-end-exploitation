#!/bin/sh
# NITF Extract GUI Front end \
exec wish "$0" ${1+"$@"}


# initialize global variables
set SOFTWARE_VERSION "May 30, 2000\nVersion 1.4"
set gHoldUserPath ""
set gFont {Courier 11}

set gJpeg_count 0
set gRaw_count 0
set gImage_has_tres 0
set gRaw1_bands 0
set gRaw1_has_tres 0
set gRaw1_datatype unknown
set gText_count 0
set gVeridian_file 0
set gIGEOLO_count 0

#**************************************************************************
# procedure init_window - Create and initialize the main Extract window
#
# parameters:
# Returns:
#
#**************************************************************************

proc init_window {} {
    global SOFTWARE_VERSION
    global gFont
    global gBgColor

    set next 0

    wm title . "Extract NITF Utility"

    # Frames:
    #
    # .mbar - menu bar frame
    # .w0 - app window frame
    # .w1 - frame for NITF Filename
    # .w2 - frame for Extract path
    # .w2a - Frame for Title of extract options
    # .w3 - frame for Extract options
    # .w3a - frame for phoenix filename
    # .w3b - frame for single metadata filename
    # .w4 - frame for Preview window
    # .w5 - frame for output log window

    frame .mbar -relief groove -bd 2
    frame .w0 ;#-width 10c -height 5c ;# -background green
    frame .w1 ;#-background red
    frame .w2 ;#-background blue
    frame .w2a ;#-background blue
    frame .w3 ;#-background red1
    frame .w4 ;#-background red1
    frame .w4a
    frame .w4b

    pack .mbar -side top -fill x
    pack .w0 -side top -fill both -expand 1
    #pack propagate .w0 0
    pack .w1 .w2 -in .w0 -side top -fill x

    pack .w3 -in .w0 -side left -fill y
    pack .w2a -in .w3 -side top


    pack .w4 -in .w0 -side left



    #*** Create Menu Bar contents

    menubutton .mbar.file -text File -underline 0 -menu .mbar.file.menu

    menu .mbar.file.menu -tearoff 0
    .mbar.file.menu add command -label Open -command {
        file_select
    }
    .mbar.file.menu add command -label Exit -command exit

    menubutton .mbar.help -text Help -underline 0 -menu .mbar.help.menu

    menu .mbar.help.menu -tearoff 0
    .mbar.help.menu add command -label About -command {
        tk_messageBox -title "About" -message "NITF Extract GUI\n$SOFTWARE_VERSION" -type ok -icon info
    }

    pack .mbar.file -side left
    pack .mbar.help -side right
    tk_menuBar .mbar .mbar.file .mbar.help


    #*** Add NITF Filename widgets

    label .l_fname -text "Filename:" -width 15
    entry .i_fname -width 30 -relief sunken -textvariable gInputFilename

    pack .l_fname -in .w1 -side left -padx 2 -pady 2
    pack .i_fname -in .w1 -side left -padx 2 -pady 2 -fill x -expand true


    # Add extract to path widgets
    label .l_output_path_name -text "Output Path:" -width 15
    entry .i_output_path_name -width 30 -relief sunken -textvariable gOutputPathname

    pack .l_output_path_name -in .w2 -side left -padx 2 -pady 2
    pack .i_output_path_name -in .w2 -side left -padx 2 -pady 2 -fill both -expand true



    #*** Extract command buttons


    button .extract -text "Extract" -command start_extract
    button .browse -text "Browse files" -command {
        if {$gHoldUserPath != ""} {
            cd $gHoldUserPath
        }
        file_select
      }
    button .preview -text "View NITF file info" -command preview_nitf_file

    pack .extract .browse .preview -in .w2a -side left -anchor w -padx 10 -pady 2


    #*** Extract methods


    label .l$next -text "Extract Methods:"
    pack .l$next -in .w3 -side top -anchor w -padx 4
    incr next

    radiobutton .separate_files -text "Extract to separate files" -variable opt_extract_method -value S -command {
            set gOutputFilename ""
            .o_fname configure -state disabled
            handle_sets_and_grays
        }

    radiobutton .text_phoenix -text "Extract text and raw data to Phoenix file" \
        -variable opt_extract_method -value TextPhoenix -command {
            #fill in output filename
            .o_fname configure -state normal

            # get filename from filename
            set file [file tail $gInputFilename]

            # remove extension
            set index [string last . $file]
            if {$index > 0} {
                set file [string range $file 0 [expr $index-1]]
            }

            # set default filenames
            set gOutputFilename "$file.phx"
            handle_sets_and_grays
        }

    radiobutton .tre_phoenix -text "Extract TREs and raw data to Phoenix file" \
        -variable opt_extract_method -value TrePhoenix -command {
            .o_fname configure -state normal

            #fill in output filename

            # get filename from filename
            set file [file tail $gInputFilename]

            # remove extension
            set index [string last . $file]
            if {$index > 0} {
                set file [string range $file 0 [expr $index-1]]
            }

            # set default filenames
            set gOutputFilename "$file.phx"
            handle_sets_and_grays
        }

    radiobutton .one_metafile -text "Extract text to one meta-data file" \
        -variable opt_extract_method -value M -command {
            .o_fname configure -state normal

            #fill in output filename

            # get filename from filename
            set file [file tail $gInputFilename]

            # remove extension
            set index [string last . $file]
            if {$index > 0} {
                set file [string range $file 0 [expr $index-1]]
            }

            # set default filenames
            set gOutputFilename "$file.metadata"
            handle_sets_and_grays
        }

    pack .separate_files .text_phoenix .tre_phoenix .one_metafile -in .w3 -side top -anchor w -padx 16

    set gBgColor [.separate_files cget -background]
    .separate_files configure -highlightbackground $gBgColor
    .text_phoenix    configure -highlightbackground $gBgColor
    .tre_phoenix    configure -highlightbackground $gBgColor
    .one_metafile   configure -highlightbackground $gBgColor


    #*** Output filename
    frame .w3a
    pack .w3a -in .w3 -side top -anchor w

    label .l$next -text "" -width 5
    pack .l$next -in .w3a -side left  -anchor w
    incr next

    label .l$next -text "Output File:" ;#-width 7
    pack .l$next -in .w3a -side left  -anchor w -padx 3 ;# -ipadx [expr 32+8]
    incr next

    entry .o_fname -width 30 -relief sunken -textvariable gOutputFilename
    pack .o_fname -in .w3a -side left  -anchor w

    label .l$next -text "" -width 1
    pack .l$next -in .w3a -side left  -anchor w
    incr next


    label .l$next -text "Extract options:"
    pack .l$next -in .w3 -side top -anchor w -padx 4
    incr next


    checkbutton .raw -text "Extract separate raw data file(s)" -variable opt_raw -highlightbackground $gBgColor
    pack .raw -in .w3 -side top -anchor w -padx 16

    checkbutton .jpeg -text "Extract separate JPEG file(s)" -variable opt_jpeg -anchor w -indicatoron 1 -highlightbackground $gBgColor
    pack .jpeg -in .w3 -side top -anchor w -padx 16


    checkbutton .t_text -text "Extract separate text files" -variable opt_text -highlightbackground $gBgColor
    pack .t_text -in .w3 -side top -anchor w -padx 16


    #*** Create TRE files
    checkbutton .tre -text "Create TREs as separate files\n(TREname_Image#_Count#.txt)" -variable opt_tre -anchor w -highlightbackground $gBgColor
    pack .tre -in .w3 -side top -anchor w  -padx 16



    checkbutton .dii -text "Create image information files (image#.txt)" -variable opt_dii -anchor w -highlightbackground $gBgColor
    pack .dii -in .w3 -side top -anchor w -padx 16

    #*** Create .geo files
    checkbutton .geo -text "Create .geo files (IMAGEname.geo)" -variable opt_geo -anchor w -highlightbackground $gBgColor
    pack .geo -in .w3 -side top -anchor w  -padx 16


    label .l$next -text "Raw Data Options:"
    pack .l$next -in .w3 -side top -anchor w -padx 4
    incr next



#    checkbutton .raw_mag_phase -text "Raw Data Mag/Phase" -variable opt_mag_phase -anchor w -highlightbackground $gBgColor

    checkbutton .raw_mag_only -text "Magnitude only" -variable opt_mag_only -anchor w -highlightbackground $gBgColor

    checkbutton .raw_qpm -text "Quarter Power Magnitude (QPM)" -variable opt_qpm -anchor w -highlightbackground $gBgColor

#    pack .raw_mag_phase -in .w3 -side top -anchor w -padx 32
    pack .raw_mag_only .raw_qpm -in .w3 -side top -anchor w -padx 16




    #catch {image delete image1a}
    image create photo logo1 -file vow25.gif -height 20;#-width 250
    #image create photo logo1 -file vow.gif -width 200 -height 46
    #image create photo logo1 -file vow.gif -width 300 -height 69
    label .l$next -image logo1 -bd 1 -relief sunken
    #pack $w.l1 $w.l2 -side top -padx .5m -pady .5m

    pack .l$next -in .w3 -side top
    incr next

    #*** Create the preview, output windows

    label .l$next -text "NITF Information Window"
    pack .l$next -side top -in .w4 -pady 4
    incr next


    pack .w4a -in .w4 -side top


    text .preview_field -yscrollcommand ".scroll_pre set" -font $gFont -height 13
    scrollbar .scroll_pre -command ".preview_field yview"

    pack .scroll_pre -in .w4a -side right -fill y -pady 2 -expand 1
    pack .preview_field -in .w4a -side left -fill both -pady 2 -expand 1


    label .l$next -text "Extract Output Window"
    pack .l$next -side top -in .w4 -pady 4
    incr next


    pack .w4b -in .w4 -side top

    text .out_field -yscrollcommand ".scroll_out set" -font $gFont -height 7
    scrollbar .scroll_out -command ".out_field yview"

    pack .scroll_out -in .w4b -side right -fill y -pady 2 -expand 1
    pack .out_field -in .w4b -side left -fill both -pady 2 -expand 1

    .separate_files invoke
}



#**************************************************************************
# procedure handle_sets_and_grays
#
#       This function handles setting and clearing checkboxes, as well as
#       disabling or enabling checkboxes and radio buttons.  It works on a
#       control by control basis because of all the conditions.
#
#
# parameters:
# Returns:
#
#**************************************************************************

proc handle_sets_and_grays {} {
    global opt_extract_method
    global opt_jpeg
    global opt_text
    global opt_raw
    global opt_mag_only
    global opt_qpm
    global opt_geo

    global gJpeg_count
    global gRaw_count
    global gImage_has_tres
    global gRaw1_has_tres
    global gRaw1_bands
    global gRaw1_datatype
    global gText_count
    global gVeridian_file
    global gIGEOLO_count


    # extract separate files

    # extract text to phoenix
    if {$gText_count == 0 || $gRaw_count == 0} {
        .text_phoenix configure -state disabled
    } else {
        .text_phoenix configure -state normal
    }

    # extract TREs to phoenix
    if {$gRaw1_has_tres == 0 || $gRaw_count == 0} {
        .tre_phoenix configure -state disabled
    } else {
        .tre_phoenix configure -state normal
    }

    # extract text to single meta-data file
    if {$gText_count == 0} {
        .one_metafile configure -state disabled
    } else {
        .one_metafile configure -state normal
    }

    # output filename


    # extract separate raw files
    #debug
    if {$gRaw_count == 0 || $opt_extract_method == "TextPhoenix" || $opt_extract_method == "TrePhoenix"} {
        .raw configure -state disabled
        set opt_raw 0
    } else {
        .raw configure -state normal
        set opt_raw 1
    }


    # extract separate JPEG files
    if {$gJpeg_count == 0} {
        .jpeg configure -state disabled
        set opt_jpeg 0
    } else {
        .jpeg configure -state normal
        set opt_jpeg 1
    }


    # extract separate Text files
    if {$gText_count == 0 || $opt_extract_method == "TextPhoenix" || $opt_extract_method == "M"} {
        .t_text configure -state disabled
        set opt_text 0
    } else {
        .t_text configure -state normal
        if {$opt_extract_method == "S"} {
            set opt_text 1
        }
    }

    # extract TREs as separate files

    # create image information files

    # create .geo files
    if {$gIGEOLO_count == 0} {
        .geo configure -state disabled
        set opt_geo 0
    } else {
        .geo configure -state normal
    }

    # mag only
    if {$gRaw_count == 0 || $gRaw1_bands != 2} {
        set opt_mag_only 0
        .raw_mag_only configure -state disabled
    } else {
        .raw_mag_only configure -state normal
    }


    # QPM
    if {$gRaw_count == 0 || $gRaw1_datatype != "float"} {
        set opt_qpm 0
        .raw_qpm configure -state disabled
    } else {
        .raw_qpm configure -state normal
    }
}



#**************************************************************************
# procedure file_select - This function opens the file browser/selector
#
# parameters:
# Returns:
#
#**************************************************************************

proc file_select {} {
    global gHoldUserPath
    global gMetadataFilename
    global gPhoenixFilename
    global opt_extract_method

    set file [fileDialog . open]
    if {$file != ""} {
        set file [tcl_filename_to_local $file]
        # set filename entry
        .i_fname delete 0 end
        .i_fname insert 0 $file
        .i_fname xview end

        # set pathname from filename
        set path [file dirname $file]
        set path [tcl_filename_to_local $path]
        set gHoldUserPath $path
        .i_output_path_name delete 0 end
        .i_output_path_name insert 0 $path
        .i_output_path_name xview end


        # get filename from pathname
        set file [file tail $file]

        # remove extension
        set index [string last . $file]
        if {$index > 0} {
            set file [string range $file 0 [expr $index-1]]
        }

        # set default filenames
        set gMetadataFilename "$file.metadata"
        set gPhoenixFilename "$file.phx"

        preview_nitf_file

        switch $opt_extract_method {
            "TextPhoenix" { .text_phoenix invoke }
            "TrePhoenix" { .tre_phoenix invoke }
            "M" { .one_metafile invoke }
        }
    }
}



#**************************************************************************
# procedure preview_nitf_file - This function opens the NITF File preview
#                              window
#
# parameters:
# Returns:
#
#**************************************************************************

proc preview_nitf_file {} {
    global env
    global gInputFilename
    global gOutputPathname
    global tcl_platform
    global gHoldUserPath
    global gFont

    global gJpeg_count
    global gRaw_count
    global gRaw1_has_tres
    global gRaw1_bands
    global gRaw1_datatype
    global gText_count
    global gVeridian_file
    global gIGEOLO_count
    global gImage_has_tres

    # check to see if file exists
    set nitf_file $gInputFilename
    if {![file exists $nitf_file]} {
        tk_messageBox -title "Error" -message "NITF File '$nitf_file' doesn't exist" -type ok -icon info
        return
    }

    # Get original cursor name
    set Cursor [.out_field cget -cursor]

    . configure -cursor watch
    .out_field configure -cursor watch
    .preview_field configure -cursor watch

    .preview_field delete 1.0 end
    .out_field delete 1.0 end

    update ;#Allow screen to update

    cd [string trim $env(nitf_extract_path)]
    set exe [string trim $env(nitf_extract_exe)]

    file delete lastrun.txt
    file delete nitfinfo.txt

    # create NITF info file
    if {[catch {exec >&lastrun.txt $exe $gInputFilename $gOutputPathname -gui} error]} {
        # error message
        tk_messageBox -title "Error" -message "Extract returned an error:\n$error" \
                     -parent . -type ok -icon info -parent .
    }


    # Open lastrun.txt file, fill in output message

    if {[catch {set fh [open lastrun.txt r]} error]} {
        tk_messageBox -message "preview_nitf_file: Error opening lastrun.txt file:\n\n$error" \
            -title Error -icon info
    } else {
        while {[gets $fh line] >= 0} {
            set line "$line\n"
            .out_field insert end $line
        }

        close $fh
    }


    # Open nitfinfo.txt file, read into text box

    if {[catch {set fh [open nitfinfo.txt r]} error]} {
        tk_messageBox -message "preview_nitf_file: Error opening nitfinfo.txt file:\n\n$error" \
            -title Error -icon info
    } else {
        while {[gets $fh line] >= 0} {
            if {$line == "<END REPORT>"} {break}
            set line "$line\n"
            .preview_field insert end $line
        }

        # Read report info

        set gJpeg_count 0
        set gRaw_count 0
        set gImage_has_tres 0
        set gRaw1_bands 0
        set gRaw1_datatype unknown
        set gText_count 0
        set gVeridian_file 0

        while {[gets $fh line] >= 0} {
            #.preview_field insert end "$line\n"
            set line_list [split $line ,]

            set first_parm [lindex $line_list 0]
            set temp [split $first_parm " "]

            set first [lindex $temp 0]

            if { $first == "-image"} {

                #find JPEG or raw, increment raw_count, jpeg_count
                set second [lindex $line_list 1]
                if {$second == "jpeg"} {
                    incr gJpeg_count

                    #find TREs
                    set temp [lindex $line_list 6]
                    set temp_list [split $temp " "]
                    set second [lindex $temp_list 1]
                    if {$second != "No"} {
                        set gImage_has_tres 1
                    }
                } elseif {$second == "raw"} {
                    incr gRaw_count

                    #find TREs
                    set temp [lindex $line_list 6]
                    set temp_list [split $temp " "]
                    set second [lindex $temp_list 1]
                    if {$second != "No"} {
                        set gImage_has_tres 1
                    }

                    #if first is raw, set gRaw1_bands, gRaw1_datatype
                    if {$gRaw_count == 1} {

                        #find TREs
                        set temp [lindex $line_list 6]
                        set temp_list [split $temp " "]
                        set second [lindex $temp_list 1]
                        if {$second != "No"} {
                            set gRaw1_has_tres 1
                        }

                        #find type
                        set temp [lindex $line_list 4]
                        set temp_list [split $temp " "]
                        set gRaw1_datatype [lindex $temp_list 1]

                        #find bands
                        set temp [lindex $line_list 5]
                        set temp_list [split $temp " "]
                        set gRaw1_bands [lindex $temp_list 1]
                    }
                }

            } elseif {$first == "-text"} {

                set gText_count [lindex $temp 1]

            } elseif {$first == "-IGEOLOs"} {

                set gIGEOLO_count [lindex $temp 1]

            } elseif {$first == "-ostaid"} {

                set temp [lindex $temp 1]

                if {$temp == "VERIDIAN"} {
                    set gVeridian_file 1
                }
            }

        }
#tk_messageBox -message "raw1_has_tres $gRaw1_has_tres text count $gText_count Veridian file: $gVeridian_file"
        close $fh
    }

#-ostaid VERIDIAN
#-image 1,jpeg,D1IY00001.sr1.mr10.jpg,TREs No TREs
#-image 2,raw,D1IY00001.sr1.mr10.hsi,nbpp 16,type uint,bands 5,TREs 'SNSRA', 'TRGTA', 'IMGDTA', 'PLTFMA', 'BANDSA'
#-symbols 0
#-graphics 0
#-labels 0
#-text 5
#-DESs 0
#-RESs 0
#-IGEOLOs 2

    . configure -cursor arrow
    .out_field configure -cursor $Cursor
    .preview_field configure -cursor $Cursor

    handle_sets_and_grays
}



#**************************************************************************
# procedure fileDialog  This function requests a file from the user
#
# parameters:
#   w           window
#   operation   "open" or "save"
#
# Returns:
#   filename
#
#**************************************************************************

proc fileDialog {w operation} {
    set types {
        {"NITF Files"      {.ntf .nitf}    }
        {"All files"        *}
    }

    #   Type names      Extension(s)    Mac File Type(s)
    #
    #---------------------------------------------------------
        #file types
        #{"Text files"       {.txt .doc} }
        #{"Text files"       {}      TEXT}
        #{"Tcl Scripts"      {.tcl}      TEXT}
        #{"C Source Files"   {.c .h}     }
        #{"All Source Files" {.tcl .c .h}    }
        #{"Image Files"      {.gif}      }
        #{"Image Files"      {.jpeg .jpg}    }
        #{"Image Files"      ""      {GIFF JPEG}}

    if {$operation == "open"} {
        set file [tk_getOpenFile -filetypes $types -parent $w]
    } else {
        set file [tk_getSaveFile -filetypes $types -parent $w \
            -initialfile Untitled -defaultextension .txt]
    }
}



#**************************************************************************
# procedure start_extract - This function runs extract using the user's
#                           parameters
#
# parameters:
# Returns:
#
#**************************************************************************

proc start_extract {} {
    global env
    global gInputFilename
    global gOutputPathname
    global gOutputFilename
    global opt_extract_method
    global opt_raw
    global opt_mag_only
    global opt_qpm
    global opt_jpeg
    global opt_dii
    global opt_text
    global opt_tre
    global opt_geo
    global gHoldUserPath
    global gBgColor

    # check to see if file exists
    set nitf_file $gInputFilename
    if {![file exists $nitf_file]} {
        tk_messageBox -title "Error" -message "NITF File '$nitf_file' doesn't exist" -type ok -icon info
        return
    }

    if {![file isdirectory $gOutputPathname]} {
        set temp [tk_messageBox -title "Error" -message "Output directory '$gOutputPathname' doesn't exist.\nDo you want to create it?" -type yesno -icon question]

        if {[string compare $temp yes] == 0} {
            file mkdir $gOutputPathname
        } else {
            return
        }
    }




    # This works: eval {exec >& c:\\out.txt printargs a b c d e}

    cd [string trim $env(nitf_extract_path)]

    file delete lastrun.txt

    set exe [string trim $env(nitf_extract_exe)]

    set build_command [list exec >&lastrun.txt $exe $gInputFilename $gOutputPathname]


    # hourglass

    . configure -cursor watch
    set Cursor [.out_field cget -cursor]
    .out_field configure -cursor watch
    .preview_field configure -cursor watch

    update


    #*** Add proper command line arguments

    switch $opt_extract_method {
        "S" {
                # separate files
                if {$opt_raw == 0 || $opt_jpeg == 0 || $opt_text == 0} {
                    if {$opt_raw == 1} {lappend build_command -raw_only}
                    if {$opt_jpeg == 1} {lappend build_command -jpeg_only}
                    if {$opt_text == 1} {lappend build_command -text_only}
                    if {$opt_tre == 1} {
                        lappend build_command -tre_only
                        lappend build_command -tre
                    }
                }
            }
        "TextPhoenix" {
                # raw+text to phoenix
                set gOutputFilename [string trim $gOutputFilename]
                if {$gOutputFilename == ""} {set gOutputFilename "dataout.phx"}
                lappend build_command -pn $gOutputFilename

                if {$opt_jpeg == 0} {lappend build_command -raw_only}

                if {$opt_tre == 1} {
                    lappend build_command -tre
                }
            }
        "TrePhoenix" {
                # raw+TREs to phoenix
                set gOutputFilename [string trim $gOutputFilename]
                if {$gOutputFilename == ""} {set gOutputFilename "dataout.phx"}
                lappend build_command -p_tre $gOutputFilename

                if {$opt_jpeg == 0 && $opt_text == 0} {lappend build_command -raw_only}
                if {$opt_jpeg == 1 && $opt_text == 0} {}
                if {$opt_jpeg == 0 && $opt_text == 1} {lappend build_command -text_only}
                if {$opt_jpeg == 1 && $opt_text == 1} {
                    lappend build_command -text_only
                    lappend build_command -jpeg_only
                }

                if {$opt_tre == 1} {
                    lappend build_command -tre
                }
            }
        "M" {
                # one meta-data file
                if {$gOutputFilename == ""} {set gOutputFilename "metadata.txt"}
                lappend build_command -f $gOutputFilename

                if {$opt_tre == 1} {
                    lappend build_command -tre_only
                    lappend build_command -tre
                }

                if {$opt_raw == 0 && $opt_jpeg == 0} {
                    lappend build_command -text_only
                } elseif {$opt_raw == 0 || $opt_jpeg == 0} {
                    if {$opt_raw == 1} {lappend build_command -raw_only}
                    if {$opt_jpeg == 1} {lappend build_command -jpeg_only}
                }
            }
    }

    set extract_raw 1

    #if {$opt_phoenix == 0 && $opt_raw == 0} {
    #    set extract_raw 0
    #}

    if {$opt_mag_only == 1} { lappend build_command -mag_only }
    if {$opt_qpm == 1} { lappend build_command -qpm }
    if {$opt_dii == 1} { lappend build_command -dii }

    if {$opt_tre == 1} {lappend build_command -tre}
    if {$opt_geo == 1} {lappend build_command -g}


    #tk_messageBox -message "build_command: '$build_command'" ;# set build_command ""

    .out_field delete 1.0 end
    update idletasks

    file delete nitfinfo.txt


    #*** Run extract, handle results

    #old: {exec >&lastrun.txt $exe $gInputFilename $gOutputPathname}
    if {[catch $build_command error]} {
        tk_messageBox -title Error -message "Extract reported an error\n\n$error" \
                 -parent . -type ok -icon info
    }


    . configure -cursor arrow
    .out_field configure -cursor $Cursor
    .preview_field configure -cursor $Cursor


    # Open lastrun.txt file, fill in output message

    if {[catch {set fh [open lastrun.txt r]} error]} {
        tk_messageBox -message "start_extract: Error opening lastrun.txt file:\n\n$error" \
            -title Error -icon info
    } else {
        while {[gets $fh line] >= 0} {
            set line "$line\n"
            .out_field insert end $line
        }

        close $fh
    }
}



#**************************************************************************
# tcl_filename_to_local     This function converts TCL's preferred format
#                           (forward slashes) to the local format
#                           (backslashes for PCs).
#
# parameters:
# Returns:
#
#**************************************************************************

proc tcl_filename_to_local {filename} {
    global tcl_platform

    if {$tcl_platform(machine) != "intel"} {
        return $filename
    }

    while {1} {
        set index [string first / $filename]
        if {$index > 0} {
            set temp1 [string range $filename 0 [expr $index-1]]
            set temp2 [string range $filename [expr $index+1] [string length $filename]]
            set filename "$temp1\\$temp2"
        } else {
            break
        }
    }
    return $filename
}



#**************************************************************************
# local_filename_to_tcl     This function converts a local filename to TCL
#                           preferred format (forward slashes).
#
# parameters:
# Returns:
#
#**************************************************************************

proc local_filename_to_tcl {filename} {
    if {$tcl_platform(machine) != "intel"} {
        return $filename
    }

    while {1} {
        set index [string first \\ $filename]
        if {$index > 0} {
            set temp1 [string range $filename 0 [expr $index-1]]
            set temp2 [string range $filename [expr $index+1] [string length $filename]]
            set filename "$temp1/$temp2"
        } else {
            break
        }
    }
    return $filename
}



#**************************************************************************
# main - Call other functions to initialize and start the Extract GUI
#
# parameters:
# Returns:
#
#**************************************************************************

#*** Make sure environment variables exist

    if {[info exists env(DFFPATH)] == 0} {
        tk_messageBox -message "Please set environment variable DFFPATH\n\
            This should be the full path name to the NITF extract tool .dff files.\n\n\
            Please see the readme file for more help." -title Error
        exit
    }

    if {[info exists env(nitf_extract_path)] == 0} {
        tk_messageBox -message "Please set environment variable nitf_extract_path\n\
            This should be the full path name to the NITF extract tool.\n\n\
            Please see the readme file for more help." -title Error
        exit
    }

    if {[info exists env(nitf_extract_exe)] == 0} {
        tk_messageBox -message "Please set environment variable nitf_extract_exe\n\
            This should be the full path and filename of the NITF extract tool.\n\n\
            Please see the readme file for more help." -title Error
        exit
    }

#set temp "c:/a/b/c"
#set temp2 [tcl_filename_to_local $temp]
#tk_messageBox -message "tcl_platform(machine) '$tcl_platform(machine)'"

#set temp3 [local_filename_to_tcl $temp2]
#tk_messageBox -message "local_filename_to_tcl returned $temp3"

    init_window



